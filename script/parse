#!/usr/bin/env ruby
require 'rubygems'
$:.unshift(File.expand_path(File.join(File.dirname(__FILE__), "..", 'lib')))
require "bundler/setup"
require 'logger'
require 'rdf/microdata'
begin
  require 'linkeddata'
rescue LoadError
  require 'rdf/turtle'
end
require 'getoptlong'
require 'open-uri'

def run(input, options)
  reader_class = RDF::Reader.for(options[:input_format].to_sym)
  raise "Reader not found for #{$input_format}" unless reader_class

  start = Time.new
  num = 0

  case options[:output_format]
  when :ntriples, :quiet
    reader_class.new(input, options).each do |statement|
      num += 1
      if options[:quiet]
        #print "."
      else
        options[:output].puts statement.to_ntriples
      end
    end
  when :rdfa
    xsl = Nokogiri::XSLT(%(<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
      <xsl:param name="indent-increment" select="'  '"/>
      <xsl:output method="html" doctype-system="about:legacy-compat"/>
 
      <xsl:template name="newline">
        <xsl:text disable-output-escaping="yes">
    </xsl:text>
      </xsl:template>
 
      <xsl:template match="comment() | processing-instruction()">
        <xsl:param name="indent" select="''"/>
        <xsl:call-template name="newline"/>
        <xsl:value-of select="$indent"/>
        <xsl:copy />
      </xsl:template>
 
      <xsl:template match="text()">
        <xsl:param name="indent" select="''"/>
        <xsl:call-template name="newline"/>
        <xsl:value-of select="$indent"/>
        <xsl:value-of select="normalize-space(.)"/>
      </xsl:template>
 
      <xsl:template match="text()[normalize-space(.)='']"/>
 
      <xsl:template match="*">
        <xsl:param name="indent" select="''"/>
        <xsl:call-template name="newline"/>
        <xsl:value-of select="$indent"/>
          <xsl:choose>
           <xsl:when test="count(child::*) > 0">
            <xsl:copy>
             <xsl:copy-of select="@*"/>
             <xsl:apply-templates select="*|text()">
               <xsl:with-param name="indent" select="concat ($indent, $indent-increment)"/>
             </xsl:apply-templates>
             <xsl:call-template name="newline"/>
             <xsl:value-of select="$indent"/>
            </xsl:copy>
           </xsl:when>
           <xsl:otherwise>
            <xsl:copy-of select="."/>
           </xsl:otherwise>
         </xsl:choose>
      </xsl:template>
    </xsl:stylesheet>).gsub(/^    /, ''))
    reader_class.new(input, options.merge(rdfa: true)) do |reader|
      reader.rdfa.xpath("//text()").each do |txt|
        txt.content = txt.content.to_s.strip
      end
      options[:output].puts xsl.apply_to(reader.rdfa).to_s
    end
  when :jsonld
    reader_class.new(input, options.merge(jsonld: true)) do |reader|
      options[:output].puts reader.jsonld.to_json(::JSON::LD::JSON_STATE)
    end
  when :inspect
    reader_class.new(input, options).each do |statement|
      num += 1
      options[:output].puts statement.inspect
    end
  else
    r = reader_class.new(input, options)
    g = RDF::Graph.new << r
    num = g.count
    options[:output].puts g.dump(options[:output_format], options.merge(prefixes: r.prefixes))
  end
  STDERR.puts
  secs = Time.new - start
  STDERR.puts "Parsed #{num} statements in #{secs} seconds @ #{num/secs} statements/second."
rescue
  fname = input.respond_to?(:path) ? input.path : "-stdin-"
  STDERR.puts("Error in #{fname}")
  raise
end

logger = Logger.new(STDERR)
logger.level = Logger::WARN
logger.formatter = lambda {|severity, datetime, progname, msg| "#{severity}: #{msg}\n"}

options = {
  verbose: false,
  validate: false,
  rdfa: false,
  logger: logger,
  output: STDOUT,
  output_format: :turtle,
  input_format: :microdata,
  standard_prefixes: true,
  base_uri: "http://example.com",
}
input = nil

opts = GetoptLong.new(
  ["--debug", GetoptLong::NO_ARGUMENT],
  ["--execute", "-e", GetoptLong::REQUIRED_ARGUMENT],
  ["--format", GetoptLong::REQUIRED_ARGUMENT],
  ["--input-format", GetoptLong::REQUIRED_ARGUMENT],
  ["--output", "-o", GetoptLong::REQUIRED_ARGUMENT],
  ["--quiet", GetoptLong::NO_ARGUMENT],
  ["--registry", GetoptLong::REQUIRED_ARGUMENT],
  ["--template", GetoptLong::REQUIRED_ARGUMENT],
  ["--uri", GetoptLong::REQUIRED_ARGUMENT],
  ["--validate", GetoptLong::NO_ARGUMENT],
  ["--verbose", GetoptLong::NO_ARGUMENT]
)
opts.each do |opt, arg|
  case opt
  when '--debug'        then logger.level = Logger::DEBUG
  when '--execute'      then input = arg
  when '--format'       then options[:output_format] = arg.to_sym
  when '--input-format' then options[:input_format] = arg.to_sym
  when '--quiet'
    options[:quiet] = options[:quiet].to_i + 1
    logger.level = Logger::FATAL
  when '--output'       then options[:output] = File.open(arg, "w")
  when '--registry'     then options[:registry_uri] = arg
  when '--template'     then options[:haml] = arg.to_sym
  when '--uri'          then options[:base_uri] = arg
  when '--verbose'      then options[:verbose] = true
  when '--validate'     then options[:validate] = true
  end
end

if ARGV.empty?
  s = input ? input : $stdin.read
  run(StringIO.new(s), options)
else
  ARGV.each do |test_file|
    run(Kernel.open(test_file), options)
  end
end
